from typing import List, Tuple, Optional
from grid_map import GridMap
from a_star import a_star_search
from llm_interface import get_llm_waypoints

def filter_dense_waypoints(waypoints: List[Tuple[int, int]], min_dist: int = 3) -> List[Tuple[int, int]]:
    """
    Remove redundant waypoints that are too close to the previous one.
    Distance is measured using Manhattan distance.
    """
    if not waypoints:
        return []

    filtered = [waypoints[0]]
    for wp in waypoints[1:]:
        dx = abs(wp[0] - filtered[-1][0])
        dy = abs(wp[1] - filtered[-1][1])
        if dx + dy >= min_dist:
            filtered.append(wp)

    return filtered

def llm_astar(grid: GridMap,
              start: Tuple[int, int],
              goal: Tuple[int, int],
              model: str = "mistral") -> Tuple[Optional[List[Tuple[int, int]]], List[Tuple[int, int]]]:
    """
    Implements LLM-A* with:
    - Obstacle filtering
    - Waypoint thinning
    - Fallback to baseline A* when needed
    """

    # Step 1: Ask LLM for waypoints
    waypoints = get_llm_waypoints(
        start=start,
        goal=goal,
        horizontal_barriers=grid.horizontal_barriers,
        vertical_barriers=grid.vertical_barriers,
        model=model
    )

    # Step 2: Remove any waypoints that lie on obstacles
    waypoints = [wp for wp in waypoints if not grid.is_occupied(*wp)]

    # Step 3: Remove closely packed waypoints
    waypoints = filter_dense_waypoints(waypoints, min_dist=3)

    if not waypoints:
        print("⚠️ No valid LLM waypoints found — defaulting to baseline A*")
        fallback_path, _ = a_star_search(grid, start, goal)
        return fallback_path, []

    # Step 4: Run A* between [start, wp1, wp2, ..., goal]
    targets = [start] + waypoints + [goal]
    full_path = []
    total_nodes = 0

    for i in range(len(targets) - 1):
        segment_path, explored = a_star_search(grid, targets[i], targets[i + 1])
        if segment_path is None:
            print(f"❌ A* failed between {targets[i]} and {targets[i + 1]}")
            print("🔁 Falling back to baseline A* from start to goal...")
            fallback_path, _ = a_star_search(grid, start, goal)
            return fallback_path, []

        if i == 0:
            full_path.extend(segment_path)
        else:
            full_path.extend(segment_path[1:])  # avoid duplicating overlap

        total_nodes += explored

    return full_path, waypoints





llm interface


import requests
import json
import ast
import re
from typing import Tuple, List

def format_repe_prompt(start: Tuple[int, int], goal: Tuple[int, int],
                       horizontal_barriers: List[List[int]],
                       vertical_barriers: List[List[int]]) -> str:
    return f"""
Identify a path between the start and goal points to navigate around obstacles and find the shortest path to the goal.
Horizontal barriers are represented as [y, x_start, x_end], and vertical barriers as [x, y_start, y_end].

Conclude your response ONLY with the generated path in the format:
Generated Path: [[x1, y1], [x2, y2], ..., [xn, yn]]

Start Point: {list(start)}
Goal Point: {list(goal)}
Horizontal Barriers: {horizontal_barriers}
Vertical Barriers: {vertical_barriers}

- First Iteration on {list(start)}
Thought:
"""

def ask_ollama(prompt: str, model: str = "mistral") -> str:
    url = "http://localhost:11434/api/generate"

    payload = {
        "model": model,
        "prompt": prompt,
        "stream": False
    }

    try:
        response = requests.post(url, json=payload)
        lines = response.text.strip().split("\n")
        full_response = ""

        for line in lines:
            data = json.loads(line)
            full_response += data.get("response", "")

        return full_response

    except Exception as e:
        return f"Error: {e}"

def get_llm_waypoints(start: Tuple[int, int], goal: Tuple[int, int],
                      horizontal_barriers: List[List[int]],
                      vertical_barriers: List[List[int]],
                      model: str = "mistral") -> List[Tuple[int, int]]:
    
    prompt = format_repe_prompt(start, goal, horizontal_barriers, vertical_barriers)
    print("📤 Sending prompt to Mistral...")

    response = ask_ollama(prompt, model=model)
    print("🧠 Mistral Response:\n", response)

    # Match cleanly the block: Generated Path: [[x1, y1], [x2, y2], ...]
    match = re.search(r"Generated Path[:：]?\s*(\[\[.*?\]\])", response, re.DOTALL)

    if not match:
        print("❌ Could not find 'Generated Path' in response.")
        return []

    try:
        path_str = match.group(1).strip()
        path = ast.literal_eval(path_str)
        path_tuples = [tuple(p) for p in path]
        return [p for p in path_tuples if p != start and p != goal]

    except Exception as e:
        print(f"❌ Error parsing generated path: {e}")
        return []
if __name__ == "__main__":
    start = (5, 5)
    goal = (20, 20)
    hbar = [[10, 0, 25]]
    vbar = [[25, 10, 22]]

    waypoints = get_llm_waypoints(start, goal, hbar, vbar)
    print("Extracted Waypoints:", waypoints)

__main__

from typing import Tuple
import time
import matplotlib.pyplot as plt
from grid_map import GridMap
from a_star import a_star_search
from llm_astar import llm_astar

def compare_astar_vs_llmastar(grid: GridMap,
                               start: Tuple[int, int],
                               goal: Tuple[int, int],
                               model: str = "mistral"):

    # --- Baseline A* ---
    print("\n🔵 Running baseline A*...")
    t0 = time.time()
    pure_path, pure_nodes = a_star_search(grid, start, goal)
    t1 = time.time()

    # --- LLM-A* ---
    print("\n🟡 Running LLM-A*...")
    t2 = time.time()
    llm_path, waypoints = llm_astar(grid, start, goal, model=model)
    t3 = time.time()

    # --- Print Summary ---
    print("\n📊 Comparison Summary:")

    if pure_path:
        print(f"✅ A* Path Length:     {len(pure_path)}")
        print(f"🔹 A* Nodes Explored:  {pure_nodes}")
        print(f"⏱️  A* Time Taken:      {t1 - t0:.3f}s")
    else:
        print("❌ A* failed to find a path.")

    if llm_path:
        print(f"\n✅ LLM-A* Path Length: {len(llm_path)}")
        print(f"⭐ LLM Waypoints Used:  {len(waypoints)}")
        print(f"⏱️  LLM-A* Time Taken:  {t3 - t2:.3f}s")
    else:
        print("\n❌ LLM-A* failed to find a path.")

    # --- Visualization ---
    fig, axs = plt.subplots(1, 2, figsize=(16, 6))

    def plot_grid(ax, title, path, waypoints=None):
        ax.set_title(title)
        ax.set_aspect('equal')
        ax.set_xlim(grid.x_min, grid.x_max)
        ax.set_ylim(grid.y_min, grid.y_max)
        ax.grid(True)

        for x in range(grid.x_min, grid.x_max):
            for y in range(grid.y_min, grid.y_max):
                if grid.is_occupied(x, y):
                    ax.add_patch(plt.Rectangle((x, y), 1, 1, color='black'))

        ax.plot(start[0] + 0.5, start[1] + 0.5, 'go', markersize=10, label="Start")
        ax.plot(goal[0] + 0.5, goal[1] + 0.5, 'ro', markersize=10, label="Goal")

        if path:
            px, py = zip(*[(x + 0.5, y + 0.5) for x, y in path])
            ax.plot(px, py, 'b-', linewidth=2, label="Path")

        if waypoints:
            for wp in waypoints:
                ax.plot(wp[0] + 0.5, wp[1] + 0.5, 'y*', markersize=12)
            ax.plot([], [], 'y*', markersize=12, label="LLM Waypoint")

        ax.legend()

    plot_grid(axs[0], "Baseline A*", pure_path)
    plot_grid(axs[1], "LLM-A*", llm_path, waypoints)
    plt.tight_layout()
    plt.show()

# --------------------------
# 🔁 Run this scenario
# --------------------------

if __name__ == "__main__":
    gmap = GridMap((0, 50), (0, 30))
    gmap.add_vertical_barrier(25, 10, 22)
    gmap.add_horizontal_barrier(10, 0, 25)

    start = (5, 5)
    goal = (20, 20)

    compare_astar_vs_llmastar(gmap, start, goal)


grid_map.py 
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple

class GridMap:
    def __init__(self, x_range: Tuple[int, int], y_range: Tuple[int, int]):
        self.x_min, self.x_max = x_range
        self.y_min, self.y_max = y_range
        self.width = self.x_max - self.x_min
        self.height = self.y_max - self.y_min

        # 2D occupancy grid: 0 = free, 1 = occupied
        self.grid = np.zeros((self.width, self.height), dtype=np.int8)

        self.vertical_barriers = []
        self.horizontal_barriers = []

    def add_vertical_barrier(self, x: int, y_start: int, y_end: int):
        self.vertical_barriers.append([x, y_start, y_end])
        for y in range(y_start, y_end + 1):
            if self.in_bounds(x, y):
                self.grid[x - self.x_min, y - self.y_min] = 1

    def add_horizontal_barrier(self, y: int, x_start: int, x_end: int):
        self.horizontal_barriers.append([y, x_start, x_end])
        for x in range(x_start, x_end + 1):
            if self.in_bounds(x, y):
                self.grid[x - self.x_min, y - self.y_min] = 1

    def in_bounds(self, x: int, y: int) -> bool:
        return self.x_min <= x < self.x_max and self.y_min <= y < self.y_max

    def is_occupied(self, x: int, y: int) -> bool:
        if not self.in_bounds(x, y):
            return True
        return self.grid[x - self.x_min, y - self.y_min] == 1

    def visualize(self, start: Tuple[int, int], goal: Tuple[int, int], path: List[Tuple[int, int]] = None, waypoints: List[Tuple[int, int]] = None):
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.set_aspect('equal')
        ax.set_xlim(self.x_min, self.x_max)
        ax.set_ylim(self.y_min, self.y_max)

        # Plot grid cells
        for x in range(self.x_min, self.x_max):
            for y in range(self.y_min, self.y_max):
                if self.is_occupied(x, y):
                    ax.add_patch(plt.Rectangle((x, y), 1, 1, color='black'))

        # Start and Goal
        ax.plot(start[0] + 0.5, start[1] + 0.5, 'go', label='Start', markersize=10)
        ax.plot(goal[0] + 0.5, goal[1] + 0.5, 'ro', label='Goal', markersize=10)

        # Path
        if path:
            px, py = zip(*[(x + 0.5, y + 0.5) for x, y in path])
            ax.plot(px, py, color='blue', linewidth=2, label='Path')

        # LLM Waypoints
        if waypoints:
            for wp in waypoints:
                ax.plot(wp[0] + 0.5, wp[1] + 0.5, 'y*', markersize=12, label='LLM Waypoint')
            ax.plot([], [], 'y*', markersize=12, label='LLM Waypoint')  # Legend entry

        ax.legend()
        plt.grid(True)
        plt.title("LLM-A* Map Environment")
        plt.show()


if __name__ == "__main__":
    gmap = GridMap((0, 50), (0, 30))
    gmap.add_vertical_barrier(25, 10, 22)
    gmap.add_horizontal_barrier(10, 0, 25)

    start = (5, 5)
    goal = (40, 25)

    gmap.visualize(start, goal)


LLM-ASTAR PY CODE -10X10 MAZE WORKING 
from typing import List, Tuple, Optional
from grid_map import GridMap
from a_star import a_star_search
from llm_interface import get_llm_waypoints


def manhattan(p1: Tuple[int, int], p2: Tuple[int, int]) -> int:
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])


def filter_dense_waypoints(waypoints: List[Tuple[int, int]], min_dist: int = 3) -> List[Tuple[int, int]]:
    """
    Remove redundant waypoints that are too close to the previous one.
    Distance is measured using Manhattan distance.
    """
    if not waypoints:
        return []

    filtered = [waypoints[0]]
    for wp in waypoints[1:]:
        if manhattan(filtered[-1], wp) >= min_dist:
            filtered.append(wp)

    return filtered


def prune_redundant_waypoints(grid: GridMap,
                               waypoints: List[Tuple[int, int]],
                               start: Tuple[int, int],
                               goal: Tuple[int, int]) -> List[Tuple[int, int]]:
    """
    Remove waypoints if A* can go directly between neighbors.
    Only keeps waypoints necessary for navigation.
    """
    targets = [start] + waypoints + [goal]
    pruned = []
    i = 0

    while i < len(targets) - 2:
        can_skip = a_star_search(grid, targets[i], targets[i + 2])[0] is not None
        if can_skip:
            i += 1  # Skip the middle
        else:
            pruned.append(targets[i + 1])
            i += 1

    if len(targets) >= 3 and targets[-2] not in pruned:
        pruned.append(targets[-2])

    return pruned


def llm_astar(grid: GridMap,
              start: Tuple[int, int],
              goal: Tuple[int, int],
              model: str = "mistral") -> Tuple[Optional[List[Tuple[int, int]]], List[Tuple[int, int]]]:
    """
    Implements LLM-A* with:
    - Obstacle filtering
    - Waypoint thinning
    - Waypoint pruning
    - Segment-wise fallback for robustness
    """

    print("📤 Querying LLM for waypoints...")
    waypoints = get_llm_waypoints(
        start=start,
        goal=goal,
        horizontal_barriers=grid.horizontal_barriers,
        vertical_barriers=grid.vertical_barriers,
        model=model
    )

    print(f"📌 Raw LLM Waypoints: {waypoints}")

    # Step 1: Remove invalid/obstructed waypoints
    waypoints = [wp for wp in waypoints if grid.in_bounds(*wp) and not grid.is_occupied(*wp)]
    if not waypoints:
        print("⚠️ No valid LLM waypoints — defaulting to baseline A*")
        fallback_path, _ = a_star_search(grid, start, goal)
        return fallback_path, []

    # Step 2: Filter densely packed waypoints
    waypoints = filter_dense_waypoints(waypoints, min_dist=3)

    # Step 3: Prune waypoints that are not needed
    waypoints = prune_redundant_waypoints(grid, waypoints, start, goal)

    print(f"✅ Filtered & Pruned Waypoints: {waypoints}")

    # Step 4: Stitch together A* path segment-wise
    targets = [start] + waypoints + [goal]
    full_path = []
    total_nodes = 0

    for i in range(len(targets) - 1):
        segment_start = targets[i]
        segment_end = targets[i + 1]
        print(f"🔄 Planning from {segment_start} to {segment_end}")
        segment_path, explored = a_star_search(grid, segment_start, segment_end)

        if segment_path is None:
            print(f"❌ Segment A* failed between {segment_start} → {segment_end}")
            print("🔁 Falling back to baseline A* from start to goal...")
            fallback_path, _ = a_star_search(grid, start, goal)
            return fallback_path, []

        # Avoid overlapping points
        if i == 0:
            full_path.extend(segment_path)
        else:
            full_path.extend(segment_path[1:])

        total_nodes += explored

    print(f"✅ Final LLM-A* Path Length: {len(full_path)}")
    return full_path, waypoints


    LLM INTERFACE PY WORKING UNTIL 29 MARCH 6 PM 
    import requests
import json
import ast
import re
from typing import Tuple, List

# Add cost awareness to influence LLM's path reasoning
COST_RULES = """
Map Cost Rules:
- Open grid cell: cost = 1.0
- Diagonal movement: cost = 1.4
- Barriers/obstacles: impassable
- The goal is to minimize total cost, not just number of steps.
"""

def format_repe_prompt(start: Tuple[int, int], goal: Tuple[int, int],
                       horizontal_barriers: List[List[int]],
                       vertical_barriers: List[List[int]]) -> str:
    return f"""
{COST_RULES}

Identify a path between the start and goal points to navigate around obstacles and find the shortest path to the goal.
Horizontal barriers are represented as [y, x_start, x_end], and vertical barriers as [x, y_start, y_end].

Conclude your response ONLY with the generated path in the format:
Generated Path: [[x1, y1], [x2, y2], ..., [xn, yn]]

Start Point: {list(start)}
Goal Point: {list(goal)}
Horizontal Barriers: {horizontal_barriers}
Vertical Barriers: {vertical_barriers}

- First Iteration on {list(start)}
Thought:
"""

def ask_ollama(prompt: str, model: str = "mistral") -> str:
    url = "http://localhost:11434/api/generate"

    payload = {
        "model": model,
        "prompt": prompt,
        "stream": False
    }

    try:
        response = requests.post(url, json=payload)
        lines = response.text.strip().split("\n")
        full_response = ""

        for line in lines:
            data = json.loads(line)
            full_response += data.get("response", "")

        return full_response

    except Exception as e:
        return f"Error: {e}"

def get_llm_waypoints(start: Tuple[int, int], goal: Tuple[int, int],
                      horizontal_barriers: List[List[int]],
                      vertical_barriers: List[List[int]],
                      model: str = "mistral") -> List[Tuple[int, int]]:

    prompt = format_repe_prompt(start, goal, horizontal_barriers, vertical_barriers)
    print("📤 Sending prompt to Mistral...")

    response = ask_ollama(prompt, model=model)
    print("🧠 Mistral Response:\n", response)

    # Match: Generated Path: [[x1, y1], [x2, y2], ...]
    match = re.search(r"Generated Path[:：]?\s*(\[\[.*?\]\])", response, re.DOTALL)

    if not match:
        print("❌ Could not find 'Generated Path' in response.")
        return []

    try:
        path_str = match.group(1).strip()
        path = ast.literal_eval(path_str)
        path_tuples = [tuple(p) for p in path]
        return [p for p in path_tuples if p != start and p != goal]

    except Exception as e:
        print(f"❌ Error parsing generated path: {e}")
        return []

# Optional testing stub
if __name__ == "__main__":
    start = (5, 5)
    goal = (20, 20)
    hbar = [[10, 0, 25]]
    vbar = [[25, 10, 22]]

    waypoints = get_llm_waypoints(start, goal, hbar, vbar)
    print("Extracted Waypoints:", waypoints)
# This is a stub for testing purposes. In practice, this would be part of the llm_astar.py module.  





###############################################################################################################################

import cv2
import time
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, List
from grid_map import GridMap
from a_star import a_star_search
from llm_astar import llm_astar
from matplotlib.backend_bases import MouseEvent
from pathlib import Path

def load_maze_from_image(image_path: str, threshold: int = 127) -> GridMap:
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise FileNotFoundError(f"❌ Could not load image: {image_path}")
    if img.shape[0] > 100 or img.shape[1] > 100:
        img = cv2.resize(img, (40, 40), interpolation=cv2.INTER_NEAREST)
    _, binary = cv2.threshold(img, threshold, 255, cv2.THRESH_BINARY)
    binary = (binary == 0).astype(np.uint8)
    h, w = binary.shape
    gmap = GridMap((0, w), (0, h))
    for y in range(h):
        for x in range(w):
            if binary[y, x] == 1:
                gmap.set_occupied(x, h - y - 1)
    return gmap

def select_points_interactively(grid: GridMap) -> Tuple[Tuple[int, int], Tuple[int, int]]:
    selected: List[Tuple[int, int]] = []

    def onclick(event: MouseEvent):
        if event.xdata is None or event.ydata is None:
            return
        x, y = int(event.xdata), int(event.ydata)
        if grid.in_bounds(x, y) and not grid.is_occupied(x, y):
            selected.append((x, y))
            print(f"✅ Selected: ({x}, {y})")
            ax.plot(x + 0.5, y + 0.5, 'go' if len(selected) == 1 else 'ro', markersize=10)
            plt.draw()
        if len(selected) == 2:
            plt.close()

    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_xlim(grid.x_min, grid.x_max)
    ax.set_ylim(grid.y_min, grid.y_max)
    ax.set_aspect('equal')
    ax.set_title("🖱️ Click Start (Green) and Goal (Red)")
    ax.grid(True)

    for x in range(grid.x_min, grid.x_max):
        for y in range(grid.y_min, grid.y_max):
            if grid.is_occupied(x, y):
                ax.add_patch(plt.Rectangle((x, y), 1, 1, color='black'))

    cid = fig.canvas.mpl_connect('button_press_event', onclick)
    plt.show()
    fig.canvas.mpl_disconnect(cid)

    if len(selected) != 2:
        raise RuntimeError("Start and goal not selected!")

    return selected[0], selected[1]

def animate_llm_path(grid: GridMap, path: List[Tuple[int, int]], start, goal):
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_xlim(grid.x_min, grid.x_max)
    ax.set_ylim(grid.y_min, grid.y_max)
    ax.set_aspect('equal')
    ax.set_title("🤖 LLM-A* Path Simulation")
    ax.grid(True)

    for x in range(grid.x_min, grid.x_max):
        for y in range(grid.y_min, grid.y_max):
            if grid.is_occupied(x, y):
                ax.add_patch(plt.Rectangle((x, y), 1, 1, color='black'))

    ax.plot(start[0] + 0.5, start[1] + 0.5, 'go', markersize=10, label="Start")
    ax.plot(goal[0] + 0.5, goal[1] + 0.5, 'ro', markersize=10, label="Goal")

    px, py = zip(*[(x + 0.5, y + 0.5) for x, y in path])
    ax.plot(px, py, 'cyan', linewidth=1.5, linestyle='--', alpha=0.5, label="Planned Path")

    trail, = ax.plot([], [], 'b-', linewidth=2, label="Robot Trail")
    robot_dot, = ax.plot([], [], 'bo', markersize=8, label="Robot")

    ax.legend(loc="upper right")
    trail_x, trail_y = [], []

    for i in range(len(path)):
        x, y = path[i]
        trail_x.append(x + 0.5)
        trail_y.append(y + 0.5)
        trail.set_data(trail_x, trail_y)
        robot_dot.set_data(x + 0.5, y + 0.5)
        plt.pause(0.2)

    plt.show()

def show_astar_path(grid: GridMap, path: List[Tuple[int, int]], start, goal):
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_xlim(grid.x_min, grid.x_max)
    ax.set_ylim(grid.y_min, grid.y_max)
    ax.set_aspect('equal')
    ax.set_title("🧭 A* Path")
    ax.grid(True)

    for x in range(grid.x_min, grid.x_max):
        for y in range(grid.y_min, grid.y_max):
            if grid.is_occupied(x, y):
                ax.add_patch(plt.Rectangle((x, y), 1, 1, color='black'))

    ax.plot(start[0] + 0.5, start[1] + 0.5, 'go', markersize=10, label="Start")
    ax.plot(goal[0] + 0.5, goal[1] + 0.5, 'ro', markersize=10, label="Goal")

    if path:
        px, py = zip(*[(x + 0.5, y + 0.5) for x, y in path])
        ax.plot(px, py, 'm-', linewidth=2, label="A* Path")

    ax.legend(loc="upper right")
    plt.show()

def compare_astar_vs_llmastar(grid: GridMap,
                               start: Tuple[int, int],
                               goal: Tuple[int, int],
                               model: str = "mistral"):

    print("\n🔵 Running baseline A*...")
    t0 = time.time()
    pure_path, pure_nodes = a_star_search(grid, start, goal)
    t1 = time.time()

    print("\n🟡 Running LLM-A*...")
    t2 = time.time()
    llm_path, waypoints = llm_astar(grid, start, goal, model=model)
    t3 = time.time()

    print("\n📊 Comparison Summary:")
    if pure_path:
        print(f"✅ A* Path Length:     {len(pure_path)}")
        print(f"🔹 A* Nodes Explored:  {pure_nodes}")
        print(f"⏱️  A* Time Taken:      {t1 - t0:.3f}s")
    else:
        print("❌ A* failed to find a path.")

    if llm_path:
        print(f"\n✅ LLM-A* Path Length: {len(llm_path)}")
        print(f"⭐ LLM Waypoints Used:  {len(waypoints)}")
        print(f"⏱️  LLM-A* Time Taken:  {t3 - t2:.3f}s")
    else:
        print("\n❌ LLM-A* failed to find a path.")

    # Visualization
    if pure_path:
        show_astar_path(grid, pure_path, start, goal)
    if llm_path:
        animate_llm_path(grid, llm_path, start, goal)

# -------------------------
# 🟢 MAIN
# -------------------------
if __name__ == "__main__":
    image_path = "/home/shrirag10/llm_astar_sim/10_ by_ 10_orthogonalmaze.png"  # Replace with your actual path
    if not Path(image_path).exists():
        print(f"❌ Maze image not found at {image_path}")
        exit(1)

    gmap = load_maze_from_image(image_path)
    start, goal = select_points_interactively(gmap)
    compare_astar_vs_llmastar(gmap, start, goal)
